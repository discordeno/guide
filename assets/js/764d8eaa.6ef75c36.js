"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[333],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=u(n),h=a,m=p["".concat(l,".").concat(h)]||p[h]||c[h]||o;return n?r.createElement(m,s(s({ref:t},d),{},{components:n})):r.createElement(m,s({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var u=2;u<o;u++)s[u]=n[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8056:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return d},default:function(){return p}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),s=["components"],i={sidebar_position:5,sidebar_label:"Step 4 - Event Handler"},l="Step 4: Creating Standalone Event Handler",u={unversionedId:"big-bot-guide/events",id:"big-bot-guide/events",title:"Step 4: Creating Standalone Event Handler",description:"Now we are about to start working on the bot code itself. The last 3 steps should be completed by the time you reach this. The event handler process will be listening for events from any number of gateway instances and be ready to handle them.",source:"@site/docs/big-bot-guide/events.md",sourceDirName:"big-bot-guide",slug:"/big-bot-guide/events",permalink:"/docs/big-bot-guide/events",editUrl:"https://github.com/discordeno/discordeno/tree/main/site/docs/big-bot-guide/events.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,sidebar_label:"Step 4 - Event Handler"},sidebar:"tutorialSidebar",previous:{title:"Step 3 - Cache",permalink:"/docs/big-bot-guide/cache"}},d=[{value:"Why Use Standalone Event Handler Process?",id:"why-use-standalone-event-handler-process",children:[],level:2},{value:"Creating Event Handlers",id:"creating-event-handlers",children:[{value:"Understanding createBot()",id:"understanding-createbot",children:[],level:3},{value:"Understanding Cache Option",id:"understanding-cache-option",children:[],level:3}],level:2},{value:"Customizing Internal Code",id:"customizing-internal-code",children:[{value:"Why Is Customizing Important?",id:"why-is-customizing-important",children:[],level:3},{value:"Customizing Process",id:"customizing-process",children:[],level:3}],level:2},{value:"Handling Incoming Gateway Events",id:"handling-incoming-gateway-events",children:[],level:2}],c={toc:d};function p(e){var t=e.components,n=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"step-4-creating-standalone-event-handler"},"Step 4: Creating Standalone Event Handler"),(0,o.kt)("p",null,"Now we are about to start working on the bot code itself. The last 3 steps should be completed by the time you reach this. The event handler process will be listening for events from any number of gateway instances and be ready to handle them."),(0,o.kt)("p",null,"In this guide, we may use the term ",(0,o.kt)("inlineCode",{parentName:"p"},"Bot")," or the term ",(0,o.kt)("inlineCode",{parentName:"p"},"event handler"),", remember that these refer to the same thing. This is your main bot code."),(0,o.kt)("h2",{id:"why-use-standalone-event-handler-process"},"Why Use Standalone Event Handler Process?"),(0,o.kt)("p",null,"The standalone event handler is the portion of your bot code that you will be changing the most. The three previous steps created processes that are intended to never be turned off. This process is designed to let you restart whenever you wish and be incredibly quick to restart. Since we don't have the delay to start up shards anymore, your code becomes reloaded instantly."),(0,o.kt)("h2",{id:"creating-event-handlers"},"Creating Event Handlers"),(0,o.kt)("p",null,"Create a file path like ",(0,o.kt)("inlineCode",{parentName:"p"},"src/bot/mod.ts"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { DISCORD_TOKEN } from "../../configs.ts";\nimport { createBot, Collection } from "../../deps.ts";\nimport { psql } from "./cache/mod.ts";\n\nexport const bot = createBot({\n  token: DISCORD_TOKEN,\n  botId: 270010330782892032n,\n  // applicationId: 270010330782892032,\n  intents: ["Guilds", "GuildMessages"],\n  events: {\n    messageCreate: function(bot, message) {\n      console.log("message arrived");\n    },\n  },\n  cache: {\n    isAsync: true,\n    customTableCreator: function(table) {\n      const tables = {\n        users: "users",\n        channels: "channels",\n        guilds: "guilds",\n        messages: "messages",\n        presences: "presences",\n        threads: "threads",\n        unavailableGuilds: "unavailableGuilds",\n        members: "members",\n      };\n\n      if (!tables[table]) throw new Error("I HACKED ITOH!");\n\n      return {\n        /** Get a single item from the table */\n        async get(key) {\n          return await psql`SELECT * FROM ${psql(\n            tables[table]\n          )} WHERE "id" = ${psql.types.bigint(key)}`;\n        },\n        /** Completely empty this table. */\n        async clear() {\n          await psql`TRUNCATE TABLE ${psql(tables[table])}`;\n        },\n        /** Delete the data related to this key from table. */\n        async delete(key) {\n          await psql`DELETE FROM ${psql(\n            tables[table]\n          )} WHERE "id" = ${psql.types.bigint(key)}`;\n          return true;\n        },\n        /** Check if there is data assigned to this key. */\n        async has(key) {\n          return Boolean(\n            await psql`SELECT 1 FROM ${psql(\n              tables[table]\n            )} WHERE "id" = ${psql.types.bigint(key)}`\n          );\n        },\n        /** Check how many items are stored in this table. */\n        async size() {\n          return (await psql`SELECT COUNT("id") FROM ${psql(tables[table])}`)\n            .count;\n        },\n        /** Store new data to this table. */\n        async set(key, data) {\n          await psql`INSERT INTO ${psql(tables[table])} ${psql(\n            data,\n            ...Object.keys(data)\n          )}`;\n          return true;\n        },\n        // THESE TWO ARE USELESS FOR CUSTOM CACHE BUT NEED TO SHUT UP TS ERRORS\n        async forEach(callback) {},\n        async filter(callback) {\n          return new Collection();\n        },\n      };\n    },\n  },\n});\n')),(0,o.kt)("p",null,"Alright that was a lot of code. Now let's break it down little by little."),(0,o.kt)("h3",{id:"understanding-createbot"},"Understanding createBot()"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Basic Keys")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token")," if you can't figure this out stop reading and find another guide please. Thanks."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"botId")," This is going to be your bot id. The reason we require this here is because we are going to set up a standalone gateway process. With most other libs, they can fill this information using the READY event. However, since our gateway is designed not to reboot, we are not going to get the READY event whenever we restart our bot. This means we won't be able to fill this information later. Another method to get the id is to use the ",(0,o.kt)("inlineCode",{parentName:"li"},"token")," but discord developers have mentioned that this behavior is not documented and not supposed to be relied on to remain stable. Due to these reasons, we chose to just require the bot id be passed here."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"applicationId")," is an optional choice if your bot is old and has a unique id different from it's bot id."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"intents"),": Provide the intents you like using strings or a number. String form supports autocomplete and type safety."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"events"),": These are your event handler functions. When a MESSAGE_CREATE event arrives from Discord it will be processed here. We will set up the routing to run these functions later in the guide but for now you can see how to set it up. Note, you can create these functions in separate files and just import them here as you wish."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"cache"),": This is going to be the cache part. We will discuss this more below.")),(0,o.kt)("h3",{id:"understanding-cache-option"},"Understanding Cache Option"),(0,o.kt)("p",null,"Since we are using a standalone gateway a custom cache is essentially required as explained in step 3 of this guide. Please remember, to mark the cache as ",(0,o.kt)("inlineCode",{parentName:"p"},"async")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"cache: {\n    isAsync: true,\n}\n")),(0,o.kt)("p",null,'When you opt into the async cache, you must also provide a table creator function. This will not actually create any tables but it will create an object with methods to manage your "tables". Man we need a better name for this. Please send recommendations to @Skillz4Killz in discord. Thanks. Until then, please blame wolf for the terrible name. :)'),(0,o.kt)("p",null,"Alrighty, now let's dig deeper into this function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const tables = {\n  users: "users",\n  channels: "channels",\n  guilds: "guilds",\n  messages: "messages",\n  presences: "presences",\n  threads: "threads",\n  unavailableGuilds: "unavailableGuilds",\n  members: "members",\n};\n\nif (!tables[table]) throw new Error("I HACKED ITOH!");\n')),(0,o.kt)("p",null,"This part of the code is only going to make sense if you are used to PGSQL. To prevent any attacks here we will forcibly control which table will be used."),(0,o.kt)("p",null,"This function must return an object with several methods on it. You can see the methods above."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"/** Get a single item from the table */\nasync get(key) {\n    // WHATEVER CODE YOU WOULD LIKE TO USE HERE\n}\n")),(0,o.kt)("p",null,"You can insert any code you desire for your cache system here. Since we were using PGSQL, we used sql queries to make these requests. However, should you need to communicate to Redis or anything else of your choice, you can do so here."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: The .filter() and .forEach() methods are unnecessary and should not be used for your bot as they are not optimized for performance. These are made for smaller bot users who would not leave itoh alone and in order to please them itoh gave them their hearts desire! LMAO!")),(0,o.kt)("h2",{id:"customizing-internal-code"},"Customizing Internal Code"),(0,o.kt)("p",null,"One of the best parts about discordeno is the flexibility. In order to show this off, we will use the ",(0,o.kt)("inlineCode",{parentName:"p"},"user")," example but you can apply this to any part of the library."),(0,o.kt)("h3",{id:"why-is-customizing-important"},"Why Is Customizing Important?"),(0,o.kt)("p",null,"At large scale, every single property can become expensive to store in your cache. For example, if your bot does not make use of a ",(0,o.kt)("inlineCode",{parentName:"p"},"channel.topic")," why storing potentially millions of strings in your memory for something you never need/user. This could save you potentially GBs of memory to just remove this one property."),(0,o.kt)("h3",{id:"customizing-process"},"Customizing Process"),(0,o.kt)("p",null,"First, let's create a file in some path like ",(0,o.kt)("inlineCode",{parentName:"p"},"src/bot/internals/mod.ts"),". Note that we will create quite a few files below simply to keep code cleaner and simpler, in expectation that it will grow more complex later. You can merge them as you wish."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { Bot } from "../../../deps.ts";\nimport { customizeBotTransformers } from "./transformers/mod.ts";\n\nexport function customizeBotInternals(bot: Bot) {\n    bot = customizeBotTransformers(bot);\n    // ADD AS MANY MORE CUSTOMIZATIONS HERE AS YOU LIKE TO HANDLERS, HELPERS, UTILS ETC...\n    return bot;\n}\n')),(0,o.kt)("p",null,"We also need to add another file now at ",(0,o.kt)("inlineCode",{parentName:"p"},"src/bot/internals/transformers/mod.ts")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Bot } from \"../../../../deps.ts\";\nimport { customizeUserTransformer } from './user.ts'\n\nexport function customizeBotTransformers(bot: Bot) {\n  bot = customizeUserTransformer(bot)\n  // ADD ANY MORE CUSTOM TRANSFORMERS HERE\n  return bot\n}\n")),(0,o.kt)("p",null,"One more file at ",(0,o.kt)("inlineCode",{parentName:"p"},"src/bot/internals/transformers/user.ts")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Bot, DiscordenoUser, transformUser } from '../../../../deps.ts'\n\nexport function customizeUserTransformer(bot: Bot) {\n  bot.transformers.user = function (bot, payload) {\n    // REMOVE USELESS PROPS OUR BOT DOESNT USE\n    const { system, locale, verified, email, flags, mfaEnabled, premiumType, publicFlags, ...user } = transformUser(\n      bot,\n      payload,\n    )\n\n    // RETURN ONLY USEFUL PROPS WE NEED TO USE AND CACHE IF NECESSARY\n    return user as DiscordenoUser\n  }\n\n  return bot;\n}\n")),(0,o.kt)("p",null,"First we override the internal transformer for the ",(0,o.kt)("inlineCode",{parentName:"p"},"user")," object. What's cool is the typings will be automatically provided :) Next, we use the ",(0,o.kt)("inlineCode",{parentName:"p"},"transformUser")," function from the lib itself to make it create the internal user version. The reason I do this is so when I update the library and a new property is added or removed i can simply update and get it. Should you desire maximum control you can remove this entirely and only have what you want no matter what discord sends. Discordeno gives you the ability to stay in control."),(0,o.kt)("p",null,"This method can be applied to any transformer, helper function, gateway event handler, util function or any part of the library. Anything and everything is possible to override. You do NOT need to fork and modify the library ever and give yourself a headache trying to maintain your fork with updates."),(0,o.kt)("h2",{id:"handling-incoming-gateway-events"},"Handling Incoming Gateway Events"),(0,o.kt)("p",null,"Remember, this is a separate process we need to make sure we are listening to incoming events from our gateway instances. Since we used http in our Gateway step, we can create an http listener here as well."))}p.isMDXComponent=!0}}]);