"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[315],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return m}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(a),m=r,p=c["".concat(l,".").concat(m)]||c[m]||h[m]||o;return a?n.createElement(p,i(i({ref:t},u),{},{components:a})):n.createElement(p,i({ref:t},u))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},5653:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return u},default:function(){return c}});var n=a(7462),r=a(3366),o=(a(7294),a(3905)),i=["components"],s={sidebar_position:3,sidebar_label:"Step 2 - Gateway"},l="Step 2: Creating A Standalone Gateway Process",d={unversionedId:"big-bot-guide/gateway",id:"big-bot-guide/gateway",title:"Step 2: Creating A Standalone Gateway Process",description:"If you are reading this, you should have your REST process completed. We are going to need it here. This process will be connecting to discord's websockets which will send you all the events.",source:"@site/docs/big-bot-guide/gateway.md",sourceDirName:"big-bot-guide",slug:"/big-bot-guide/gateway",permalink:"/docs/big-bot-guide/gateway",editUrl:"https://github.com/discordeno/discordeno/tree/main/site/docs/big-bot-guide/gateway.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,sidebar_label:"Step 2 - Gateway"},sidebar:"tutorialSidebar",previous:{title:"Step 1 - REST",permalink:"/docs/big-bot-guide/rest"},next:{title:"Step 3 - Cache",permalink:"/docs/big-bot-guide/cache"}},u=[{value:"Why Use Standalone REST Process?",id:"why-use-standalone-rest-process",children:[],level:2},{value:"Creating Gateway Manager",id:"creating-gateway-manager",children:[{value:"Getting Gateway Bot Data",id:"getting-gateway-bot-data",children:[],level:3},{value:"Understanding Gateway Manager",id:"understanding-gateway-manager",children:[{value:"Gateway Cache",id:"gateway-cache",children:[],level:4},{value:"Gateway Method Overriding",id:"gateway-method-overriding",children:[],level:4}],level:3},{value:"Handle Discord Payloads",id:"handle-discord-payloads",children:[],level:3}],level:2},{value:"Spawning Shards",id:"spawning-shards",children:[],level:2},{value:"Workers",id:"workers",children:[],level:2}],h={toc:u};function c(e){var t=e.components,a=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"step-2-creating-a-standalone-gateway-process"},"Step 2: Creating A Standalone Gateway Process"),(0,o.kt)("p",null,"If you are reading this, you should have your REST process completed. We are going to need it here. This process will be connecting to discord's websockets which will send you all the events."),(0,o.kt)("p",null,"Before, we dive into how, here is a quick summary of why you will want a standalone gateway process."),(0,o.kt)("h2",{id:"why-use-standalone-rest-process"},"Why Use Standalone REST Process?"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Zero Downtime Updates"),":"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Your bot can be updated in a matter of seconds. With normal sharding, you\nhave to restart which also has to process identifying all your shards with a\n1/~5s rate limit. With WS handling moved to a proxy process, this allows you\nto instantly get the bot code restarted without any concerns of delays. If\nyou have a bot on 200,000 servers normally this would mean a 20 minute delay\nto restart your bot if you made a small change and restarted."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Zero Downtime Resharding"),":"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Discord stops letting your bot get added to new servers at certain points in\ntime. For example, suppose you had 150,000 servers running 150 shards. The\nmaximum amount of servers your shards could hold is 150 ","*"," 2500 = 375,000. If\nyour bot reaches this, it can no longer join new servers until it re-shards."),(0,o.kt)("li",{parentName:"ul"},"DD proxy provides 2 types of re-sharding. Automated and manual. You can also\nhave both.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Automated"),": This system will automatically begin a Zero-downtime\nresharding process behind the scenes when you reach 80% of your maximum\nservers allowed by your shards. For example, since 375,000 was the max, at\n300,000 we would begin re-sharding behind the scenes with ",(0,o.kt)("inlineCode",{parentName:"li"},"ZERO DOWNTIME"),".",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"80% of maximum servers reached (The % of 80% is customizable.)"),(0,o.kt)("li",{parentName:"ul"},"Identify limits have room to allow re-sharding. (Also customizable)"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Manual"),": You can also trigger this manually should you choose."))))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Horizontal Scaling"),":"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The proxy system allows you to scale the bot horizontally. When you reach a\nhuge size, you can either keep spending more money to keep beefing up your\nserver or you can buy several cheaper servers and scale horizontally. The\nproxy means you can have WS handling on a completely separate system."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"No Loss Restarts"),":"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"When you restart a bot without the proxy system, normally you would lose\nmany events. Users may be using commands or messages are sent that will not\nbe filtered. As your bot's grow this number rises dramatically. Users may\njoin who wont get the auto-roles or any other actions your bot should take.\nWith the proxy system, you can keep restarting your bot and never lose any\nevents. Events will be put into a queue while your bot is down(max size of\nqueue is customizable), once the bot is available the queue will begin\nprocessing all events."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Controllers"),":"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The controller aspect gives you full control over everything inside the\nproxy. You can provide a function to simply override the handler. For\nexample, if you would like a certain function to do something different,\ninstead of having to fork and maintain your fork, you can just provide a\nfunction to override."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Clustering With Workers"),":"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Take full advantage of all your CPU cores by using workers to spread the\nload. Control how many shards per worker and how many workers to maximize\nefficiency!")))),(0,o.kt)("h2",{id:"creating-gateway-manager"},"Creating Gateway Manager"),(0,o.kt)("p",null,"Create a file under some path like ",(0,o.kt)("inlineCode",{parentName:"p"},"src/gateway/mod.ts"),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { DISCORD_TOKEN, REST_AUTHORIZATION, REST_PORT } from "../../configs.ts";\nimport { BASE_URL, createRestManager } from "../../deps.ts";\n\nconst rest = createRestManager({\n  token: DISCORD_TOKEN,\n  secretKey: REST_AUTHORIZATION,\n  customUrl: `http://localhost:${REST_PORT}`,\n});\n')),(0,o.kt)("p",null,"Throw another rest manager here which will be responsible for calling the main REST process we created in Step 1. This will allow your gateway to communicate to the other process. Remember this is just to communicate outwards, this file should not have the http listener."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Feel free to refactor and optimize this should you wish to move ",(0,o.kt)("inlineCode",{parentName:"p"},"const rest...")," to a separate file and reuse in both steps.")),(0,o.kt)("h3",{id:"getting-gateway-bot-data"},"Getting Gateway Bot Data"),(0,o.kt)("p",null,"Now we need to use this rest manager to call the api to get information about how to connect to discord's gateway for your bot."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const rest = createRestManager({\n  token: DISCORD_TOKEN,\n  secretKey: REST_AUTHORIZATION,\n  customUrl: `http://localhost:${REST_PORT}`,\n});\n\n// CALL THE REST PROCESS TO GET GATEWAY DATA\nconst result = await rest.runMethod(rest, 'get', endpoints.GATEWAY_BOT).then((res) => ({\n  url: res.url,\n  shards: res.shards,\n  sessionStartLimit: {\n    total: res.session_start_limit.total,\n    remaining: res.session_start_limit.remaining,\n    resetAfter: res.session_start_limit.reset_after,\n    maxConcurrency: res.session_start_limit.max_concurrency,\n  },\n}));\n")),(0,o.kt)("p",null,"With this info, we can now create our gateway manager."),(0,o.kt)("h3",{id:"understanding-gateway-manager"},"Understanding Gateway Manager"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const gateway = createGatewayManager({\n  secretKey: EVENT_HANDLER_SECRET_KEY,\n  token: DISCORD_TOKEN,\n  intents: ['GuildMessages', 'Guilds'],\n  shardsRecommended: result.shards,\n  sessionStartLimitTotal: result.sessionStartLimit.total,\n  sessionStartLimitRemaining: result.sessionStartLimit.remaining,\n  sessionStartLimitResetAfter: result.sessionStartLimit.resetAfter,\n  maxConcurrency: result.sessionStartLimit.maxConcurrency,\n  maxShards: result.shards,\n  lastShardId: result.shards,\n  // debug: console.log,\n  handleDiscordPayload: async function (_, data, shardId) {\n    await fetch(`${EVENT_HANDLER_URL}:${EVENT_HANDLER_PORT}`, {\n      headers: {\n        Authorization: gateway.secretKey,\n        method: 'POST',\n        body: JSON.stringify({\n          shardId,\n          data,\n        }),\n      },\n    })\n      // BELOW IS FOR SOLVING DENO MEMORY LEAK. Node users do your thing.\n      .then((res) => res.text())\n      .catch(() => null)\n  },\n})\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Basic Keys")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"EVENT_HANDLER_SECRET_KEY")," is from your configs that will be used to make sure requests sent to your event handler process are indeed from you."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DISCORD_TOKEN")," if you can't figure this out, this guide isn't for you. Please find another."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"intents")," pass in a number or a string of intents. Autocomplete/type-safety is provided for strings :)")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Discord Data Keys"),":  These keys will be the data you got from the gateway request we made earlier."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"shardsRecommended")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"sessionStartLimitTotal")," "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"sessionStartLimitRemaining")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"sessionStartLimitResetAfter")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"maxConcurrency"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Powerful Keys")),(0,o.kt)("p",null,"If your bot is going to be run on one process, you can re-use the data that discord gave you to connect. "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"maxShards"),": is the maximum number of shards you want to use for connecting your bot. Should you think Discord is not smart enough to recommend a good amount, use this to override their choice. Highly recommend just using theirs."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"lastShardId"),": is the last shard you want to connect in this process.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Using a combination of ",(0,o.kt)("inlineCode",{parentName:"li"},"lastShardId")," & ",(0,o.kt)("inlineCode",{parentName:"li"},"firstShardId"),", you can create several processes or even several servers to handle different amounts of shards should your bot get that big to require horizontal scaling. You can control how many shards each gateway manager will be responsible for."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"reshard"),": Whether or not to automatically reshard the bot when necessary with zero downtime deployment strategy. Default: true."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"reshardPercentage"),": The % of servers to trigger a reshard. Default: 80%."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"spawnShardDelay"),': The delay in milliseconds to wait before spawning next shard. OPTIMAL IS ABOVE 2500. YOU DON"T WANT TO HIT THE RATE LIMIT!!! This is mainly if you are changing internals a lot and need to modify this behavior.'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"useOptimalLargeBotSharding"),": Whether or not the resharder should automatically switch to LARGE BOT SHARDING when you are above 100K servers."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"shardsPerCluster"),": The amount of shards to load per worker. Discussed in detail below."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"maxClusters"),": The maximum amount of workers to use for your bot.")),(0,o.kt)("h4",{id:"gateway-cache"},"Gateway Cache"),(0,o.kt)("p",null,"There is a few things that we cache in the gateway process directly, because sending them across the network is not ideal. This is done to support custom cache functionality."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"guildIds"),": Used for determining what type of GUILD_CREATE event is received."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"loadingGuildIds"),": Used for determining if all guilds have arrived when initially connecting."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"editedMessages"),": Used to prevent spam of events across the network. MESSAGE_UPDATE are an extremely heavy event. Any embed or link that is in a message will unfurl triggerring a message update event. This is undesired behavior for 99% of bots out there. If someone sends a message with 5 urls, in there you will get a MESSAGE_CREATE and 5 MESSAGE_UPDATE events. If that user edits a single letter on it you now get 6 MESSAGE_UPDATE events, 1 for the content change and 5 more for each url being unfurled. The editedMessages cache checks if the content of the message changed or not before sending the event downstream. Override this behavior if you need different behavior. ")),(0,o.kt)("h4",{id:"gateway-method-overriding"},"Gateway Method Overriding"),(0,o.kt)("p",null,"One of the benefits of Discordeno is that you can override/customize anything from the library. Should you desire to change the logic in any method it is as simple as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// TYPINGS WILL BE AUTOMATICALLY PROVIDED\ngateway.heartbeat = function(gateway, shardId, interval) {\n    // YOUR CUSTOM HANDLING CODE HERE\n}\n")),(0,o.kt)("h3",{id:"handle-discord-payloads"},"Handle Discord Payloads"),(0,o.kt)("p",null,"One of the big things we didn't cover yet is the handler for discord payloads. This is the main sauce of your gateway process here. This is going to take the events that the gateway manager processed and send it to your event handler. How you wish to communicate with your event handler is up to you. For this guide, we will use http, but you can replace that with anything you like. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"handleDiscordPayload: async function (_, data, shardId) {\n    // CHANGE FROM SENDING THROUGH HTTP TO USING A WS FOR FASTER PROCESSING! OR HTTP3 OR WHATEVER!\n    await fetch(`${EVENT_HANDLER_URL}:${EVENT_HANDLER_PORT}`, {\n      headers: {\n        Authorization: gateway.secretKey,\n        method: 'POST',\n        body: JSON.stringify({\n          shardId,\n          data,\n        }),\n      },\n    })\n      // BELOW IS FOR SOLVING DENO MEMORY LEAK. Node users do your thing.\n      .then((res) => res.text())\n      .catch(() => null)\n  },\n")),(0,o.kt)("p",null,"You can change this function to use a WS or any form of communication you prefer to use to send this to your event handler."),(0,o.kt)("h2",{id:"spawning-shards"},"Spawning Shards"),(0,o.kt)("p",null,"Once you are ready and the gateway has been created as you desired, we can begin spawning the shards."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"gateway.spawnShards(gateway)\n")),(0,o.kt)("h2",{id:"workers"},"Workers"),(0,o.kt)("p",null,"Now, we should take a minute here to talk about workers. Workers are just Clusters in Node.js"),(0,o.kt)("p",null,"When you have a big bot and you are processing millions of events, you need to speed up that processing. Keeping it in 1 thread is not very nice since JavaScript is single threaded. This means it can only process 1 event at a time. With workers, you can make it process several events at the same time. We mentioned the ",(0,o.kt)("inlineCode",{parentName:"p"},"shardsPerCluster")," earlier. This option was added to allow you to choose how many shards should be managed by each worker."),(0,o.kt)("p",null,"When shards are spawn they are triggered by a method on gateway."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"gateway.tellClusterToIdentify = async function(gateway, workerId, shardId, bucketId) {\n  await gateway.identify(gateway, shardId, gateway.maxShards);\n}\n")),(0,o.kt)("p",null,"You can choose to replace the handler with any desired functionality you like. For example, should should you want to create a new worker for each new workerId that appears and have that worker trigger the identify functionaly. How you choose to handler workers is left in your care."))}c.isMDXComponent=!0}}]);